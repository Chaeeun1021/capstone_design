{"version":3,"sources":["VideoPlayer.js","Timeline.js","PastDataViewer.js","App.js","index.js"],"names":["VideoPlayer","memo","_ref","src","coordinates","onTimeUpdate","showOverlay","videoRef","useRef","player","setPlayer","useState","videoDimensions","setVideoDimensions","width","height","updateVideoDimensions","videoElement","current","videoWidth","videoHeight","useEffect","hls","Hls","isSupported","loadSource","attachMedia","on","Events","MANIFEST_PARSED","play","ERROR","event","data","console","error","canPlayType","addEventListener","playerInstance","videojs","controls","autoplay","muted","fluid","preload","handleTimeUpdate","currentTime","timestamp","Date","toISOString","replace","split","formattedTimestamp","concat","slice","dispose","destroy","React","createElement","className","ref","playsInline","length","map","box","index","scaledBox","points","_videoRef$current","container","getBoundingClientRect","scaleX","scaleY","_ref2","x","y","scaleCoordinates","key","style","position","left","top","p","join","fill","stroke","strokeWidth","Timeline","PastDataViewer","selectedStartDate","setSelectedStartDate","selectedEndDate","setSelectedEndDate","selectedStartTime","setSelectedStartTime","selectedEndTime","setSelectedEndTime","dataList","setDataList","setCoordinates","loading","setLoading","canvasRef","imageContainerRef","canvas","ctx","getContext","imageContainer","containerWidth","offsetWidth","containerHeight","offsetHeight","clearRect","widthRatio","heightRatio","forEach","topLeft","bottomRight","strokeStyle","lineWidth","strokeRect","alt","DatePicker","selected","onChange","date","dateFormat","placeholderText","type","value","e","target","timeFormat","onClick","handleFetchData","alert","offset","getTimezoneOffset","startDate","getTime","endDate","startTime","endTime","axios","get","params","start_date","start_time","end_date","end_time","then","response","responseData","newCoordinates","flatMap","item","drawing","Array","isArray","topRight","bottomLeft","parsedDrawing","JSON","parse","catch","disabled","dateTime","boundingCount","App","clientRef","Client","brokerURL","reconnectDelay","heartbeatIncoming","heartbeatOutgoing","onConnect","log","subscribe","message","body","onStompError","frame","headers","onWebSocketClose","onWebSocketError","activate","deactivate","Router","NavLink","to","isActive","fontWeight","end","Routes","Route","path","element","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.1e8b4288.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState, memo } from 'react';\r\nimport videojs from 'video.js';\r\nimport Hls from 'hls.js';\r\nimport 'video.js/dist/video-js.css';\r\nimport './VideoPlayer.css';\r\n\r\nconst VideoPlayer = memo(({ src, coordinates = [], onTimeUpdate, showOverlay }) => {\r\n  const videoRef = useRef(null);\r\n  const [player, setPlayer] = useState(null);\r\n  const [videoDimensions, setVideoDimensions] = useState({ width: 0, height: 0 });\r\n\r\n  // 비디오 메타데이터가 로드될 때 비디오 크기 업데이트\r\n  const updateVideoDimensions = () => {\r\n    const videoElement = videoRef.current;\r\n    if (videoElement && videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {\r\n      setVideoDimensions({\r\n        width: videoElement.videoWidth,\r\n        height: videoElement.videoHeight,\r\n      });\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    const videoElement = videoRef.current;\r\n\r\n    if (!videoElement) return;\r\n\r\n    let hls;\r\n    if (Hls.isSupported()) {\r\n      hls = new Hls();\r\n      hls.loadSource(src);\r\n      hls.attachMedia(videoElement);\r\n\r\n      hls.on(Hls.Events.MANIFEST_PARSED, () => {\r\n        videoElement.play();\r\n        updateVideoDimensions(); // 메타데이터가 로드되면 비디오 크기 업데이트\r\n      });\r\n\r\n      hls.on(Hls.Events.ERROR, (event, data) => {\r\n        console.error('HLS.js Error:', data);\r\n      });\r\n    } else if (videoElement.canPlayType('application/vnd.apple.mpegurl')) {\r\n      videoElement.src = src;\r\n      videoElement.addEventListener('loadedmetadata', () => {\r\n        videoElement.play();\r\n        updateVideoDimensions(); // 메타데이터가 로드되면 비디오 크기 업데이트\r\n      });\r\n    } else {\r\n      console.error('HLS is not supported in this browser.');\r\n    }\r\n\r\n    const playerInstance = videojs(videoElement, {\r\n      controls: true,\r\n      autoplay: true,\r\n      muted: true, // 자동 재생 허용을 위한 음소거\r\n      fluid: true,\r\n      preload: 'auto',\r\n    });\r\n\r\n    setPlayer(playerInstance);\r\n\r\n    const handleTimeUpdate = () => {\r\n      if (!playerInstance) return;\r\n      const currentTime = playerInstance.currentTime();\r\n      const currentDate = new Date(currentTime * 1000);\r\n\r\n      const timestamp = currentDate\r\n        .toISOString()\r\n        .replace(/[-:T]/g, '')\r\n        .split('.')[0];\r\n      const formattedTimestamp = `${timestamp.slice(0, 8)}_${timestamp.slice(8)}`;\r\n\r\n      onTimeUpdate(formattedTimestamp);\r\n    };\r\n\r\n    playerInstance.on('timeupdate', handleTimeUpdate);\r\n\r\n    // 정리 작업\r\n    return () => {\r\n      if (playerInstance) {\r\n        playerInstance.dispose();\r\n      }\r\n      if (hls) {\r\n        hls.destroy();\r\n      }\r\n    };\r\n  }, [src, onTimeUpdate]);\r\n\r\n  // 좌표 스케일링 함수\r\n  const scaleCoordinates = (points) => {\r\n    const { width: videoWidth, height: videoHeight } = videoDimensions;\r\n    const container = videoRef.current?.getBoundingClientRect();\r\n\r\n    if (!container || videoWidth === 0 || videoHeight === 0) {\r\n      return points;\r\n    }\r\n\r\n    const scaleX = container.width / videoWidth;\r\n    const scaleY = container.height / videoHeight;\r\n\r\n    return points.map(({ x, y }) => ({\r\n      x: x * scaleX,\r\n      y: y * scaleY,\r\n    }));\r\n  };\r\n\r\n  return (\r\n    <div className=\"video-container\">\r\n      <div className=\"video-wrapper\">\r\n        <video\r\n          ref={videoRef}\r\n          className=\"video-js vjs-default-skin vjs-big-play-centered\"\r\n          controls\r\n          playsInline\r\n        />\r\n        {showOverlay && coordinates.length > 0 && (\r\n          <div className=\"overlay\">\r\n            {coordinates.map((box, index) => {\r\n              const scaledBox = scaleCoordinates(box);\r\n              return (\r\n                <svg key={index} style={{ position: 'absolute', left: 0, top: 0, width: '100%', height: '100%' }}>\r\n                  <polygon\r\n                    points={scaledBox.map(p => `${p.x},${p.y}`).join(' ')}\r\n                    style={{\r\n                      fill: 'none',\r\n                      stroke: 'red',\r\n                      strokeWidth: 2,\r\n                    }}\r\n                  />\r\n                </svg>\r\n              );\r\n            })}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default VideoPlayer;\r\n","import React from 'react';\r\n\r\nfunction Timeline() {\r\n  return (\r\n    <div>\r\n      <h3>Timeline Component</h3>\r\n      {/* Timeline UI 구현 */}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Timeline;\r\n\r\n","import React, { useState, useRef, useEffect } from 'react';\r\nimport DatePicker from 'react-datepicker';\r\nimport 'react-datepicker/dist/react-datepicker.css';\r\nimport axios from 'axios';\r\nimport './PastDataViewer.css'\r\n\r\nfunction PastDataViewer() {\r\n  const [selectedStartDate, setSelectedStartDate] = useState(null);\r\n  const [selectedEndDate, setSelectedEndDate] = useState(null);\r\n  const [selectedStartTime, setSelectedStartTime] = useState('00:00:00');\r\n  const [selectedEndTime, setSelectedEndTime] = useState('23:59:59');\r\n  const [dataList, setDataList] = useState([]);\r\n  const [coordinates, setCoordinates] = useState([]);\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  const imageSrc = \"/beach2.PNG\"; // 이미지 경로\r\n  const canvasRef = useRef(null);\r\n  const imageContainerRef = useRef(null);\r\n\r\n  const handleFetchData = () => {\r\n    if (!selectedStartDate || !selectedEndDate) {\r\n      alert('날짜를 선택하세요!');\r\n      return;\r\n    }\r\n\r\n    if (selectedStartDate > selectedEndDate) {\r\n      alert('시작 날짜는 종료 날짜보다 먼저여야 합니다.');\r\n      return;\r\n    }\r\n\r\n    setLoading(true);\r\n\r\n    const offset = selectedStartDate.getTimezoneOffset() * 60000;\r\n    const startDate = new Date(selectedStartDate.getTime() - offset).toISOString().split('T')[0];\r\n    const endDate = new Date(selectedEndDate.getTime() - offset).toISOString().split('T')[0];\r\n\r\n    const startTime = (selectedStartTime.split(':').length === 2 ? `${selectedStartTime}:00` : selectedStartTime);\r\n    const endTime = (selectedEndTime.split(':').length === 2 ? `${selectedEndTime}:00` : selectedEndTime);\r\n\r\n    axios\r\n      .get('https://port-0-rip-lyuhc4uac61f92ea.sel4.cloudtype.app/ripList/period', {\r\n        params: {\r\n          start_date: startDate,\r\n          start_time: startTime,\r\n          end_date: endDate,\r\n          end_time: endTime,\r\n        },\r\n      })\r\n      .then((response) => {\r\n        const responseData = response.data;\r\n\r\n        const newCoordinates = responseData.flatMap((item) => {\r\n          if (typeof item.drawing === 'string') {\r\n            try {\r\n              const parsedDrawing = JSON.parse(item.drawing);\r\n              if (Array.isArray(parsedDrawing) && parsedDrawing.length === 4) {\r\n                const [topLeft, topRight, bottomRight, bottomLeft] = parsedDrawing;\r\n                return [{\r\n                  topLeft: { x: topLeft[0], y: topLeft[1] },\r\n                  bottomRight: { x: bottomRight[0], y: bottomRight[1] },\r\n                }];\r\n              }\r\n            } catch (error) {\r\n              console.error('Error parsing drawing:', error);\r\n              return [];\r\n            }\r\n          } else if (Array.isArray(item.drawing) && item.drawing.length === 4) {\r\n            const [topLeft, topRight, bottomRight, bottomLeft] = item.drawing;\r\n            return [{\r\n              topLeft: { x: topLeft[0], y: topLeft[1] },\r\n              bottomRight: { x: bottomRight[0], y: bottomRight[1] },\r\n            }];\r\n          } else {\r\n            console.error('Invalid drawing format:', item.drawing);\r\n            return [];\r\n          }\r\n        });\r\n\r\n        setCoordinates(newCoordinates);\r\n        setDataList(responseData);\r\n        setLoading(false);\r\n      })\r\n      .catch((error) => {\r\n        console.error('Error fetching data:', error);\r\n        setLoading(false);\r\n      });\r\n  };\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    const imageContainer = imageContainerRef.current;\r\n\r\n    // 이미지 컨테이너의 크기 계산\r\n    const containerWidth = imageContainer.offsetWidth;\r\n    const containerHeight = imageContainer.offsetHeight;\r\n\r\n    // 캔버스 크기 조정\r\n    canvas.width = containerWidth;\r\n    canvas.height = containerHeight;\r\n\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // 원본 이미지 크기 (1920x1080)\r\n    const originalWidth = 1920;\r\n    const originalHeight = 1080;\r\n\r\n    // 크기 비율 계산\r\n    const widthRatio = containerWidth / originalWidth;\r\n    const heightRatio = containerHeight / originalHeight;\r\n\r\n    coordinates.forEach(({ topLeft, bottomRight }) => {\r\n      // 좌표 변환\r\n      const x = topLeft.x * widthRatio;\r\n      const y = topLeft.y * heightRatio;\r\n      const width = (bottomRight.x - topLeft.x) * widthRatio;\r\n      const height = (bottomRight.y - topLeft.y) * heightRatio;\r\n\r\n      // 사각형 그리기\r\n      ctx.strokeStyle = 'red';\r\n      ctx.lineWidth = 2;\r\n      ctx.strokeRect(x, y, width, height);\r\n    });\r\n  }, [coordinates]);\r\n\r\n  return (\r\n    <div className=\"layout-wrapper\">\r\n      <div className=\"image-container\" ref={imageContainerRef}>\r\n        <img src={imageSrc} alt=\"Beach Scene\" className=\"responsive-image\" />\r\n        <canvas ref={canvasRef} style={{ position: 'absolute', top: 0, left: 0 }} />\r\n      </div>\r\n\r\n      <div className=\"left-panel\">\r\n        <h2>과거 데이터 조회</h2>\r\n        <div className=\"datetime-picker\">\r\n          <label>시작 날짜:</label>\r\n          <DatePicker\r\n            selected={selectedStartDate}\r\n            onChange={(date) => setSelectedStartDate(date)}\r\n            dateFormat=\"yyyy-MM-dd\"\r\n            className=\"custom-datepicker\"\r\n            placeholderText=\"시작 날짜를 선택하세요\"\r\n          />\r\n        </div>\r\n\r\n        <div className=\"datetime-picker\">\r\n          <label>종료 날짜:</label>\r\n          <DatePicker\r\n            selected={selectedEndDate}\r\n            onChange={(date) => setSelectedEndDate(date)}\r\n            dateFormat=\"yyyy-MM-dd\"\r\n            className=\"custom-datepicker\"\r\n            placeholderText=\"종료 날짜를 선택하세요\"\r\n          />\r\n        </div>\r\n\r\n        <div className=\"datetime-picker\">\r\n          <label>시작 시간:</label>\r\n          <input\r\n            type=\"time\"\r\n            value={selectedStartTime}\r\n            onChange={(e) => setSelectedStartTime(e.target.value)}\r\n            timeFormat=\"HH:mm:ss\"\r\n            className=\"custom-timepicker\"\r\n          />\r\n        </div>\r\n\r\n        <div className=\"datetime-picker\">\r\n          <label>종료 시간:</label>\r\n          <input\r\n            type=\"time\"\r\n            value={selectedEndTime}\r\n            onChange={(e) => setSelectedEndTime(e.target.value)}\r\n            timeFormat=\"HH:mm:ss\"\r\n            className=\"custom-timepicker\"\r\n          />\r\n        </div>\r\n\r\n        <button onClick={handleFetchData} disabled={loading} className=\"custom-button\">\r\n          {loading ? '데이터 불러오는 중...' : '데이터 조회'}\r\n        </button>\r\n\r\n        <div className=\"data-list\">\r\n          <h3>기간 내 발생 데이터 정보</h3>\r\n          {loading ? (\r\n            <p>데이터를 불러오는 중...</p>\r\n          ) : (\r\n            <ul className=\"scrollable-list\">\r\n              {dataList.length > 0 ? (\r\n                dataList.map((item, index) => (\r\n                  <li key={index}>\r\n                    {index + 1}. {item.dateTime} (Bounding Count: {item.boundingCount})\r\n                  </li>\r\n                ))\r\n              ) : (\r\n                <p>표시할 데이터가 없습니다.</p>\r\n              )}\r\n            </ul>\r\n          )}\r\n        </div>\r\n\r\n        <button className=\"download-button\">다운로드</button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default PastDataViewer;\r\n","import React, { useEffect, useState, useRef } from 'react';\r\nimport { BrowserRouter as Router, Route, NavLink, Routes } from 'react-router-dom';\r\nimport './App.css';\r\nimport VideoPlayer from './VideoPlayer';\r\nimport Timeline from './Timeline';\r\nimport PastDataViewer from './PastDataViewer';\r\nimport { Client } from '@stomp/stompjs'; // STOMP 클라이언트 사용\r\n\r\nfunction App() {\r\n  const hlsStreamUrl = 'http://4.217.235.155/stream/index.m3u8'; // HLS 비디오 스트림 URL\r\n  const [coordinates, setCoordinates] = useState([]); // 좌표 데이터\r\n  const clientRef = useRef(null); // STOMP 클라이언트 인스턴스를 저장하는 ref\r\n\r\n  // WebSocket 연결 함수\r\n  const connectWebSocket = () => {\r\n    if (!clientRef.current) {\r\n      clientRef.current = new Client({\r\n        brokerURL: 'ws://port-0-rip-lyuhc4uac61f92ea.sel4.cloudtype.app/ws', // WebSocket 서버 URL\r\n        reconnectDelay: 5000,\r\n        heartbeatIncoming: 4000,\r\n        heartbeatOutgoing: 4000,\r\n\r\n        onConnect: () => {\r\n          console.log('WebSocket connection established.');\r\n\r\n          // STOMP 메시지 구독\r\n          clientRef.current.subscribe('/topic/ripData', (message) => {\r\n            const data = JSON.parse(message.body);\r\n            console.log('Received message:', data);\r\n\r\n            if (data.drawing) {\r\n              // 좌표 데이터 업데이트 (각 모서리 좌표로 변환)\r\n              const newCoordinates = data.drawing.map((box) => {\r\n                return [\r\n                  { x: box[0][0], y: box[0][1] }, // Top-left\r\n                  { x: box[1][0], y: box[1][1] }, // Top-right\r\n                  { x: box[2][0], y: box[2][1] }, // Bottom-right\r\n                  { x: box[3][0], y: box[3][1] }, // Bottom-left\r\n                ];\r\n              });\r\n\r\n              setCoordinates(newCoordinates); // 좌표 업데이트\r\n            }\r\n          });\r\n        },\r\n\r\n        onStompError: (frame) => {\r\n          console.error('Broker reported error: ' + frame.headers['message']);\r\n          console.error('Additional details: ' + frame.body);\r\n        },\r\n\r\n        onWebSocketClose: (event) => {\r\n          console.error('WebSocket connection closed: ', event);\r\n        },\r\n\r\n        onWebSocketError: (event) => {\r\n          console.error('WebSocket error: ', event);\r\n        }\r\n      });\r\n\r\n      clientRef.current.activate(); // WebSocket 연결 시작\r\n    }\r\n  };\r\n\r\n  // WebSocket 연결 및 정리\r\n  useEffect(() => {\r\n    connectWebSocket();\r\n\r\n    return () => {\r\n      if (clientRef.current) {\r\n        clientRef.current.deactivate();\r\n        console.log('WebSocket connection closed on cleanup.');\r\n      }\r\n    };\r\n  }, []); // 처음 렌더링 시 WebSocket 연결\r\n\r\n  return (\r\n    <Router>\r\n      <div className=\"App\">\r\n        <header className=\"App-header\">\r\n          <nav>\r\n            <ul>\r\n              <li>\r\n                <NavLink to=\"/\" style={({ isActive }) => ({ fontWeight: isActive ? 'bold' : 'normal' })} end>\r\n                  실시간 영상\r\n                </NavLink>\r\n              </li>\r\n              <li>\r\n                <NavLink to=\"/pastData\" style={({ isActive }) => ({ fontWeight: isActive ? 'bold' : 'normal' })}>\r\n                  과거 데이터 조회\r\n                </NavLink>\r\n              </li>\r\n            </ul>\r\n          </nav>\r\n        </header>\r\n        <main className=\"main-content\">\r\n          <Routes>\r\n            <Route \r\n              path=\"/\" \r\n              element={<VideoPlayer \r\n                          src={hlsStreamUrl} \r\n                          coordinates={coordinates} \r\n                          showOverlay={true} // 오버레이 표시를 위한 prop\r\n                       />} \r\n            />\r\n            <Route path=\"/pastData\" element={<PastDataViewer />} />\r\n          </Routes>\r\n        </main>\r\n        <footer>\r\n          <Timeline />\r\n        </footer>\r\n      </div>\r\n    </Router>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App/>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);"],"sourceRoot":""}